import time
from os import path
from sys import exit
from dialog import Dialog
from re import compile as re_compile
from modules.UtilsClass import Utils
from modules.LoggerClass import Logger
#from modules.ElasticClass import Elastic
#from modules.TelegramClass import Telegram
from modules.ConfigurationClass import Configuration

"""
Class that allows you to manage everything related to forms and data entry.
"""
class FormDialogs:
	"""
	Property that stores an object of type Dialog.
	"""
	d = None

	"""
	Property that stores an object of type Utils.
	"""
	utils = None

	"""
	Property that stores an object of type Elastic.
	"""
	elastic = None

	"""
	Property that stores an object of type Telegram.
	"""
	telegram = None

	"""
	Property that stores an object of type Logger.
	"""
	logger = None

	"""
	Constructor for the FormDialogs class.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	"""
	def __init__(self):
		self.logger = Logger()
		self.utils = Utils(self)
		self.d = Dialog(dialog = "dialog")
		self.d.set_background_title("SNAP-TOOL")
		#self.elastic = Elastic()
		#self.telegram = Telegram()
		
	"""
	Method that generates the menu interface.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	options -- List of options that make up the menu.
	title -- Title displayed on the interface.

	Return:
	tag_mm -- Chosen option.
	"""
	def getMenu(self, options, title):
		code_mm, tag_mm = self.d.menu("Choose an option:", choices = options, title = title)
		if code_mm == self.d.OK:
			return tag_mm
		if code_mm == self.d.CANCEL:
			exit(0)

	"""
	Method that generates the message interface with scroll box.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	text -- Text that will be shown to the user.
	title -- Title that will be given to the interface and that will be shown to the user.
	"""
	def getScrollBox(self, text, title):
		code_sb = self.d.scrollbox(text, 15, 70, title = title)
		if code_sb == self.d.OK:
			self.mainMenu()

	"""
	Method generated by the interface to select a file or directory.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	initial_path -- Initial path where the interface will place the user.
	title -- Title that will be given to the interface and that will be shown to the user.

	Return:
	tag_df -- Path of the selected file.
	"""
	def getFile(self, initial_path, title):
		while True:
			code_fd, tag_df = self.d.fselect(initial_path, 8, 50, title = title)
			if code_fd == self.d.OK:
				if tag_df == "":
					self.d.msgbox("\nSelect a file.", 7, 50, title = "Error Message")
				else:
					return tag_df
			if code_fd == self.d.CANCEL:
				self.mainMenu()

	"""
	"""
	def getDirectory(self, initial_path, title):
		while True:
			code_dd, tag_dd = self.d.dselect(initial_path, 8, 50, title = title)
			if code_dd == self.d.OK:
				if tag_dd == "":
					self.d.msgbox("\nSelect a directory:", 8, 50, title = "Error Message")
				else:
					return tag_dd
			if code_dd == self.d.CANCEL:
				self.mainMenu()

	"""
	Method that generates an interface with several
	available options, and where only one of them can be
	chosen.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	text -- Text displayed on the interface.
	options -- List of options that make up the interface.
	title -- Title displayed on the interface.

	Return:
	tag_rl -- Chosen option.
	"""
	def getDataRadioList(self, text, options, title):
		while True:
			code_rl, tag_rl = self.d.radiolist(
					  text,
					  width = 65,
					  choices = options,
					  title = title)
			if code_rl == self.d.OK:
				if len(tag_rl) == 0:
					self.d.msgbox("\nSelect at least one option.", 7, 50, title = "Error Message")
				else:
					return tag_rl
			if code_rl == self.d.CANCEL:
				self.mainMenu()

	"""
	Method that generates the interface with a list of options, where you can choose one or more.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	text -- Text that will be shown to the user.
	options -- List of options that make up the interface.
	title -- Title that will be given to the interface and that will be shown to the user.

	Return:
	tag_cl -- List with the chosen options.
	"""
	def getDataCheckList(self, text, options, title):
		while True:
			code_cl, tag_cl = self.d.checklist(
					 text,
					 width = 75,
					 choices = options,
					 title = title)
			if code_cl == self.d.OK:
				if len(tag_cl) == 0:
					self.d.msgbox("\nSelect at least one option.", 7, 50, title = "Error message")
				else:
					return tag_cl
			if code_cl == self.d.CANCEL:
				self.mainMenu()

	"""
	Method that generates the interface for entering decimal
	or floating type data.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	text -- Text displayed on the interface.
	initial_value -- Default value shown on the interface.

	Return:
	tag_nd -- Decimal or float value entered.
	"""
	def getDataNumberDecimal(self, text, initial_value):
		decimal_reg_exp = re_compile(r'^[1-9](\.[0-9]+)?$')
		while True:
			code_nd, tag_nd = self.d.inputbox(text, 10, 50, initial_value)
			if code_nd == self.d.OK:
				if(not self.utils.validateRegularExpression(decimal_reg_exp, tag_nd)):
					self.d.msgbox("\nInvalid data entered. Required value (decimal or float).", 8, 50, title = "Error Message")
				else:
					return tag_nd
			if code_nd == self.d.CANCEL:
				self.mainMenu()

	"""
	Method that generates an interface to enter an IP
	address.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	text -- Text displayed on the interface.
	initial_value -- Default value shown on the interface.

	Return:
	tag_ip -- IP address entered.
	"""
	def getDataIP(self, text, initial_value):
		ip_reg_exp = re_compile(r'^(?:(?:[1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}(?:[1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$|^localhost$')
		while True:
			code_ip, tag_ip = self.d.inputbox(text, 10, 50, initial_value)
			if code_ip == self.d.OK:
				if(not self.utils.validateRegularExpression(ip_reg_exp, tag_ip)):
					self.d.msgbox("\nInvalid data entered. Required value (IP address).", 8, 50, title = "Error Message")
				else:
					return tag_ip
			if code_ip == self.d.CANCEL:
				self.mainMenu()

	"""
	Method that generates an interface to enter a port.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	text -- Text displayed on the interface.
	initial_value -- Default value shown on the interface.

	Return:
	tag_port -- Port entered.
	"""
	def getDataPort(self, text, initial_value):
		port_reg_exp = re_compile(r'^([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$')
		while True:
			code_port, tag_port = self.d.inputbox(text, 10, 50, initial_value)
			if code_port == self.d.OK:
				if(not self.utils.validateRegularExpression(port_reg_exp, tag_port)):
					self.d.msgbox("\nInvalid data entered. Required value (0 - 65535).", 8, 50, title = "Error Message")
				else:
					return tag_port
			if code_port == self.d.CANCEL:
				self.mainMenu()

	"""
	Method that generates a decision-making interface
	(yes / no).

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	text -- Text displayed on the interface.
	title -- Title displayed on the interface.

	Return:
	tag_yesorno -- Chosen option (yes or no).
	"""
	def getDataYesOrNo(self, text, title):
		tag_yesorno = self.d.yesno(text, 10, 50, title = title)
		return tag_yesorno

	"""
	Method that generates an interface to enter text.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	text -- Text displayed on the interface.
	initial_value -- Default value shown on the interface.

	Return:
	tag_input -- Text entered.
	"""
	def getDataInputText(self, text, initial_value):
		while True:
			code_input, tag_input = self.d.inputbox(text, 10, 50, initial_value)
			if code_input == self.d.OK:
				if tag_input == "":
					self.d.msgbox("\nInvalid data entered. Required value (not empty).", 8, 50, title = "Error Message")
				else:
					return tag_input
			if code_input == self.d.CANCEL:
				self.mainMenu()

	"""
	Method that generates an interface to enter a password.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	text -- Text displayed on the interface.
	initial_value -- Default value shown on the interface.

	Return:
	tag_pass -- Password entered.
	"""
	def getDataPassword(self, text, initial_value):
		while True:
			code_pass, tag_pass = self.d.passwordbox(text, 10, 50, initial_value, insecure = True)
			if code_pass == self.d.OK:
				if tag_pass == "":
					self.d.msgbox("\nInvalid data entered. Required value (not empty).", 8, 50, title = "Error Message")
				else:
					return tag_pass
			if code_pass == self.d.CANCEL:
				self.mainMenu()

	"""
	Method that defines the action to be performed on the
	Snap-Tool configuration file (creation or modification).

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	"""
	def defineConfiguration(self):
		configuration = Configuration(self)

		options_conf_false = [("Create", "Create the configuration file", 0)]

		options_conf_true = [("Modify", "Modify the configuration file", 0)]

		if not path.exists(self.utils.getPathSnapTool("conf") + "/snap_tool_conf.yaml"):
			opt_conf_false = self.getDataRadioList("Select a option:", options_conf_false, "Configuration Options")
			if opt_conf_false == "Create":
				configuration.createConfiguration()
		else:
			opt_conf_true = self.getDataRadioList("Select a option:", options_conf_true, "Configuration Options")
			if opt_conf_true == "Modify":
				configuration.updateConfiguration()

	"""
	Method that obtains the list of indexes and select one of them to create a snapshot of it.

	Parameters:
	self -- An instantiated object of the FormDialogs class.

	Exceptions:
	KeyError -- A Python KeyError exception is what is raised when you try to access a key that isn’t in a dictionary (dict).
	"""
	def getCreateSnapshot(self):
		if not os.path.exists(self.utils.getPathSTool("conf") + "/es_conf.yaml"):
			self.d.msgbox("\nConfiguration file not found", 7, 50, title = "Error message")
		else:
			snap_tool_conf = self.utils.readFileYaml(self.utils.getPathSTool('conf') + '/es_conf.yaml', FormDialogs())
			if float(snap_tool_conf['es_version']) < 7.0:
				self.d.msgbox("\nElasticSearch version not supported", 7, 50, title = "Error message")
			else:
				try:
					conn_es = self.elastic.getConnectionElastic(snap_tool_conf, FormDialogs())
					list_indices = self.elastic.getIndices(conn_es)
					if len(list_indices) == 0:
						self.d.msgbox("\nThere are no indexes", 7, 50, title = "Notification message")
					else:
						option_index = self.getDataRadioList("Select a option:", list_indices, "ElasticSearch Indexes")
						self.elastic.createSnapshot(conn_es, snap_tool_conf['repository_name'], option_index, FormDialogs())
						message_create = self.telegram.getTelegramMessage("create_snapshot", option_index)
						status_code_create = self.telegram.sendTelegramAlert(self.utils.decryptAES(snap_tool_conf['telegram_chat_id'], FormDialogs()).decode('utf-8'), self.utils.decryptAES(snap_tool_conf['telegram_bot_token'], FormDialogs()).decode('utf-8'), message_create)
						self.telegram.getStatusByTelegramCode(status_code_create)
						self.logger.createLogTool("Snapshot creation started: " + option_index, 2)
						while True:
							status_snapshot = self.elastic.getStatusSnapshot(conn_es, snap_tool_conf['repository_name'], option_index, FormDialogs())
							if status_snapshot == 'SUCCESS':
								break
							time.sleep(60)
						status_snapshot_end = self.elastic.getStatus(conn_es, snap_tool_conf['repository_name'], option_index, FormDialogs())
						message = self.telegram.getTelegramMessage("end_snapshot", option_index)
						message += self.telegram.getMessageEndSnapshot(status_snapshot_end['snapshots'][0]['start_time'], status_snapshot_end['snapshots'][0]['end_time'])
						status_code = self.telegram.sendTelegramAlert(self.utils.decryptAES(snap_tool_conf['telegram_chat_id'], FormDialogs()).decode('utf-8'), self.utils.decryptAES(snap_tool_conf['telegram_bot_token'], FormDialogs()).decode('utf-8'), message)
						self.telegram.getStatusByTelegramCode(status_code)
						self.logger.createLogTool("Snapshot creation completed: " + option_index, 2)
						self.d.msgbox("\nSnapshot created. Index:\n- " + option_index, 7, 50, title = "Notification message")
						delete_index = self.getDataYesOrNo("\nDo you want to delete the index that was backed up in the snapshot?\n\n- " + option_index, "Delete Index")
						if delete_index == "ok":
							self.elastic.deleteIndex(conn_es, option_index)
							message_rindex = self.telegram.getTelegramMessage("delete_index", option_index)
							status_code_rindex = self.telegram.sendTelegramAlert(self.utils.decryptAES(snap_tool_conf['telegram_chat_id'], FormDialogs()).decode('utf-8'), self.utils.decryptAES(snap_tool_conf['telegram_bot_token'], FormDialogs()).decode('utf-8'), message_rindex)
							self.telegram.getStatusByTelegramCode(status_code_rindex)
							self.logger.createLogTool("The index has been removed: " + option_index, 2)
							self.d.msgbox("\nThe index has been removed: " + option_index, 7, 50, title = "Notification message")
					self.mainMenu()
				except KeyError as exception:
					self.logger.createLogTool("Key Error: " + str(exception), 4)
					self.d.msgbox("\nKey Error: " + str(exception), 7, 50, title = "Error message")		
					sys.exit(1)

	"""
	Method that lists all the snapshots created and allows one or more to be selected for deletion.

	Parameters:
	self -- An instantiated object of the FormDialogs class.

	Exceptions:
	KeyError -- A Python KeyError exception is what is raised when you try to access a key that isn’t in a dictionary (dict). 
	"""
	def getDeleteSnapshot(self):
		if not os.path.exists(self.utils.getPathSTool("conf") + "/es_conf.yaml"):
			self.d.msgbox("\nConfiguration file not found", 7, 50, title = "Error message")
		else:
			snap_tool_conf = self.utils.readFileYaml(self.utils.getPathSTool('conf') + '/es_conf.yaml', FormDialogs())
			if float(snap_tool_conf['es_version']) < 7.0:
				self.d.msgbox("\nElasticSearch version not supported", 7, 50, title = "Error message")
			else:
				try:
					conn_es = self.elastic.getConnectionElastic(snap_tool_conf, FormDialogs())
					list_snapshots = self.elastic.getSnapshots(conn_es, snap_tool_conf['repository_name'], FormDialogs())
					if len(list_snapshots) == 0:
						self.d.msgbox("\nThere are no snapshots to delete", 7, 50, title = "Notification message")
					else:
						option_snapshot = self.getDataCheckList("Select a option:", list_snapshots, "ElasticSearch Snapshots")
						delete_snapshot = self.getDataYesOrNo("\nAre you sure to delete the selected snapshot (s)?\n\n- " + ", ".join(option_snapshot), "Delete Snapshot")
						if delete_snapshot == "ok":
							for snapshot in option_snapshot:
								self.elastic.deleteSnapshot(conn_es, snap_tool_conf['repository_name'], snapshot, FormDialogs())
								message = self.telegram.getTelegramMessage("delete_snapshot", snapshot)
								status_code = self.telegram.sendTelegramAlert(self.utils.decryptAES(snap_tool_conf['telegram_chat_id'], FormDialogs()).decode('utf-8'), self.utils.decryptAES(snap_tool_conf['telegram_bot_token'], FormDialogs()).decode('utf-8'), message)
								self.telegram.getStatusByTelegramCode(status_code)
								self.logger.createLogTool("Snaphot removed: " + snapshot, 2)
							self.d.msgbox("\nThe snapshot(s) have been deleted:\n- " + ", ".join(option_snapshot), 7, 50, title = "Notification message")
					self.mainMenu()
				except KeyError as exception:
					self.logger.createLogTool("Key Error: " + str(exception), 4)
					self.d.msgbox("\nKey Error: " + str(exception), 7, 50, title = "Error message")
					sys.exit(1)

	"""
	Method that obtains the list of created snapshots allows selecting one and mounting it as a searchable snapshot.

	Parameters:
	self -- An instantiated object of the FormDialogs class.

	Exceptions:
	KeyError -- A Python KeyError exception is what is raised when you try to access a key that isn’t in a dictionary (dict). 
	"""
	def getCreateSearchSnapshot(self):
		if not os.path.exists(self.utils.getPathSTool("conf") + "/es_conf.yaml"):
			self.d.msgbox("\nConfiguration file not found", 7, 50, title = "Error message")
		else:
			snap_tool_conf = self.utils.readFileYaml(self.utils.getPathSTool('conf') + '/es_conf.yaml', FormDialogs())
			if float(snap_tool_conf['es_version']) < 7.0:
				self.d.msgbox("\nElasticSearch version not supported", 7, 50, title = "Error message")
			else:
				try:
					conn_es = self.elastic.getConnectionElastic(snap_tool_conf, FormDialogs())
					list_snapshots = self.elastic.getSnapshots(conn_es, snap_tool_conf['repository_name'], FormDialogs())
					if len(list_snapshots) == 0:
						self.d.msgbox("\nThere are no snapshots to delete", 7, 50, title = "Notification message")
					else:
						option_snapshot = self.getDataRadioList("Select a option:", list_snapshots, "ElasticSearch Snapshots")
						self.elastic.mountSearchableSnapshots(conn_es, snap_tool_conf['repository_name'], option_snapshot, FormDialogs())
						message = self.telegram.getTelegramMessage("mount_snapshot", option_snapshot)
						status_code = self.telegram.sendTelegramAlert(self.utils.decryptAES(snap_tool_conf['telegram_chat_id'], FormDialogs()).decode('utf-8'), self.utils.decryptAES(snap_tool_conf['telegram_bot_token'], FormDialogs()).decode('utf-8'), message)
						self.telegram.getStatusByTelegramCode(status_code)
						self.logger.createLogTool("Snapshot mounted as searchable snapshot: " + option_snapshot, 2)
						self.d.msgbox("\nSnapshot mounted as a searchable snapshot: " + option_snapshot, 7, 50, title = "Notification message")
					self.mainMenu()
				except KeyError as exception:
					self.logger.createLogTool("Key Error: " + str(exception), 4)
					self.d.msgbox("\nKey Error: " + str(exception), 7, 50, title = "Error message")
					exit(1)

	"""
	Method that displays a message on the screen with information about the application.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	"""
	def getAbout(self):
		message = "\nCopyright@2021 Tekium. All rights reserved.\nSnap-Tool v3.0\nAuthor: Erick Rodriguez erickrr.tbd93@gmail.com\n" + "License: GPLv3\n\nSnap-Tool is a tool that allows the management of snaphots in\nElasticSearch through a graphical interface."
		self.getScrollBox(message, "About")

	"""
	Method that launches an action based on the option chosen
	in the main menu.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	option -- Chosen option.
	"""
	def switchMmenu(self, option):
		if option == 1:
			self.defineConfiguration()
		"""if option == 2:
			self.getCreateSnapshot()
		if option == 3:
			self.getDeleteSnapshot()
		if option == 4:
			self.getCreateSearchSnapshot()
		if option == 5:
			self.getAbout()
		if option == 6:
			self.elastic.getInformationNodesElastic()
		if option == 8:
			exit(0)"""

	"""
	Method that defines the menu on the actions to be carried
	out in the main menu.

	Parameters:
	self -- An instantiated object of the FormDialogs class.
	"""
	def mainMenu(self):
		options_mm = [("1", "Snap-Tool Configuration"),
					  ("2", "Create repository"),
					  ("3", "Create Snapshot"),
					  ("4", "Delete Snapshot"),
					  ("5", "Create Searchable Snapshot"),
					  ("6", "Nodes information"),
					  ("7", "About"),
					  ("8", "Exit")]

		option_mm = self.getMenu(options_mm, "Main Menu")
		self.switchMmenu(int(option_mm))